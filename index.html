<!-- Updated Starfield with Twinkling Glimmer -->
<script>
  // Initialize background scene & camera
  const bgScene = new THREE.Scene();
  const bgCam = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 1, 1000);
  bgCam.position.z = 50;
  const bgRenderer = new THREE.WebGLRenderer({ canvas: document.getElementById('bg'), alpha: true });
  bgRenderer.setSize(window.innerWidth, window.innerHeight);

  // Create star texture
  function createStarTexture() {
    const s = 64;
    const c = document.createElement('canvas');
    c.width = s;
    c.height = s;
    const ctx = c.getContext('2d');
    const grad = ctx.createRadialGradient(s/2, s/2, 0, s/2, s/2, s/2);
    grad.addColorStop(0, 'rgba(255,255,255,1)');
    grad.addColorStop(0.2, 'rgba(255,255,255,1)');
    grad.addColorStop(0.4, 'rgba(200,200,200,0.4)');
    grad.addColorStop(1, 'rgba(0,0,0,0)');
    ctx.fillStyle = grad;
    ctx.fillRect(0,0,s,s);
    return new THREE.CanvasTexture(c);
  }
  const starTex = createStarTexture();

  // Build starfield geometry
  const starCount = 1500;
  const starGeo = new THREE.BufferGeometry();
  const positions = new Float32Array(starCount * 3);
  const sizes = new Float32Array(starCount);
  const speeds = new Float32Array(starCount);
  const phases = new Float32Array(starCount);

  for (let i = 0; i < starCount; i++) {
    positions[i*3] = (Math.random() - 0.5) * 500;
    positions[i*3+1] = (Math.random() - 0.5) * 500;
    positions[i*3+2] = (Math.random() - 0.5) * 500;
    sizes[i] = (Math.random() * 1.5 + 0.5) * 4;
    speeds[i] = Math.random() * 0.002 + 0.001;         // Twinkle speed
    phases[i] = Math.random() * Math.PI * 2;          // Phase offset
  }
  starGeo.setAttribute('position', new THREE.BufferAttribute(positions, 3));
  starGeo.setAttribute('size', new THREE.BufferAttribute(sizes, 1));
  starGeo.setAttribute('speed', new THREE.BufferAttribute(speeds, 1));
  starGeo.setAttribute('phase', new THREE.BufferAttribute(phases, 1));

  // Shader material with time-based flicker
  const starMat = new THREE.ShaderMaterial({
    uniforms: {
      pointTexture: { value: starTex },
      time: { value: 0 }
    },
    vertexShader: `attribute float size; attribute float speed; attribute float phase;
      uniform float time;
      void main() {
        float twinkle = 1.0 + sin(time * speed * 100.0 + phase) * 0.6;
        vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);
        gl_PointSize = size * (300.0 / -mvPosition.z) * twinkle;
        gl_Position = projectionMatrix * mvPosition;
      }`,
    fragmentShader: `uniform sampler2D pointTexture;
      void main() {
        vec4 color = texture2D(pointTexture, gl_PointCoord);
        gl_FragColor = color;
      }`,
    blending: THREE.AdditiveBlending,
    depthTest: false,
    transparent: true
  });

  const stars = new THREE.Points(starGeo, starMat);
  bgScene.add(stars);

  // Animate stars
  function animateStars() {
    requestAnimationFrame(animateStars);
    starMat.uniforms.time.value += 0.01;
    stars.rotation.y += 0.0001;
    stars.rotation.x += 0.0001;
    bgRenderer.render(bgScene, bgCam);
  }
  animateStars();

  // Handle resize
  window.addEventListener('resize', () => {
    bgCam.aspect = window.innerWidth / window.innerHeight;
    bgCam.updateProjectionMatrix();
    bgRenderer.setSize(window.innerWidth, window.innerHeight);
  });
</script>
